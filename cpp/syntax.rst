.. highlight:: cpp

C++ синтаксисі
==============

Ең қарапайым бағдарлама
--------------------

C++ тілінде екі санды қосатын ең қарапайым бағдарлама келесідей::

    #include <iostream>

    using namespace std;

    int main() {
        int a, b;
        cin >> a >> b;
        int s = a + b;
        cout << s << endl;
        return 0;
    }

Оны жол-жолға бөліп талдайық.

::

    #include <iostream>

(Мұндағы бұрыштық жақшалар жай ғана ``<`` кіші және ``>`` үлкен таңбалар болып табылады.)

C++ тіліндегі ``#`` таңбасынан басталатын жолдар *компилятор директивалары* (немесе дәлірек айтқанда - *препроцессорлық директивалар*) деп аталады.
Барлық басқа тілдік құрылымдардан айырмашылығы, олар бөлек жолға жазылуы керек.

``#include <iostream>`` директивасы, шамамен айтқанда, пернетақтадан енгізу және экранға шығарумен жұмыс істеу мүмкіндігін береді.
C++ тіліндегі ``#include`` директивасы Python тіліндегі ``import`` және Паскаль тіліндегі ``uss`` сияқты - бұл бағдарламада кейбір қосымша функциялар мен конструкцияларды пайдалануға мүмкіндік береді.

``#include`` белгісінен кейін көрсетілген нәрсе *тақырып файлы* деп аталады. «Модуль» терминін қолданудың қажеті жоқ,
ол Python және Pascal тілдерінде ұқсас жағдайда қолданылады; C++ модульдері мүлдем басқа жағдай (және шын мәнінде тек C++ 20 бастап қол жетімді).

.. note ::

     Айта кету керек, ``#include`` компилятор директивасы өте қарапайым мағынаға ие: ол көрсетілген файлдың мазмұнын алады (біздің жағдайда стандартты компилятор пакетіне кіретін ``iostream``) және оны директива жазылған бағдарламаңыздағы орынға (include) енгізеді. Яғни, `#include <iostream> " жазбасы компиляторға "iostream файлының мазмұнын ағымдағы файлдың берілген жерінде жазылғандай оқыңыз, содан кейін ағымдағы файлды әрі қарай оқыңыз" дегенді білдіреді. Сәйкесінше, стандартты `iostream` тақырып файлы пернетақта мен экранмен жұмыс істеу үшін қажет функциялардың, деректер түрлерінің және т.б. заттардың тақырыптарын сипаттайды. Ол функциялардың толық кодын емес, тек атауларын жақсы сипаттауы мүмкін (код дайын кітапханаларда жинақталған болуы мүмкін), бірақ бұл тақырыптарды компилятор одан әрі сіздің бағдарламаңызды құрастыру үшін қажет етеді. Сондықтан,  ``iostream`` сияқты файлдар тақырыптар деп аталады және көбінесе ``.h`` деп аяқталатын файлдарды оқиды.

    Шын мәнінде, ``#include`` директивасын тек тақырып файлдарын қосу үшін ғана емес, сонымен қатар басқа файлдан кодты енгізу керек кез келген жерде пайдалануға болады. Бірақ сізге жақын арада қажет болмайтын өте сирек жағдайларды қоспағанда, мұны істеудің қажеті жоқ.

    Сондай-ақ, ``#include`` директивасының болуының өзі С++ тілінің (дәлірек айтсақ, директива мұраланған Си тілі) өте ежелгі бағдарламалау тілі екенін көрсететінін атап өтейік. Басқа файлдардан кодты қандай да бір жолмен қосу қажеттілігі бағдарламалау тілдерінің басында пайда болғаны анық және бағдарламаның ағымдағы орнында басқа файлдың кодын жай ғана қамтитын конструкциялар жасаудың ең қарапайым тәсілдерінің бірі екені анық. Қазіргі заманғы тілдерде модульдер сияқты жүйелер бар, олар бір жағынан күрделірек (компиляторда іске асыру тұрғысынан), бірақ екінші жағынан дәлірек және бірқатар артықшылықтарға ие; Қазіргі тілдердегі ``#include`` сияқты конструкциялар тек кейбір қарапайым белгілеу тілдерінде немесе тілдің өзі өте қарапайым болған кезде ғана кездеседі.

Келесі жолға көшейік.

::

    using namespace std;

Бұл жол, namespace ``std`` атаулар кеңістігін қосады. Онсыз көптеген стандартты функциялар, типтер, айнымалылар және т.б. `std::` префиксімен жазу керек болар еді, мысалы, `cin` орнына `std::cin` жазу керек (`cin` біз бағдарламадан әрі қарай көреміз).
`Using namespace` сізге жаңа мүмкіндіктерді пайдалануға мүмкіндік бермейді (`#include` - тен айырмашылығы), ол қазірдің өзінде қосылған мүмкіндіктерге қол жеткізу тәсілін өзгертеді.

C++ - дағы маңызды бағдарламаларда ``using namespace`` командаларын қолдану ұсынылмайды, бірақ біздің кішігірім бағдарламаларда оларды қолдануға болады.

Қазіргі уақытта атаулар кеңістігінің қандай екенін толық түсінудің қажеті жоқ, тек осы жолды есте сақтаңыз немесе келесі жазбаны оқыңыз.

.. note ::

     Барлық функциялар, типтер, айнымалылар және т.б. (әрі қарай қарапайымдылық үшін Мен тек функциялар туралы сөйлесемін) C++ *атаулар кеңістігі* бойынша бөлінеді. 
     Бағдарламада дәл осылай жариялауға болатын барлық мүмкіндіктерге сәйкес келетін глобалды атаулар кеңістігі бар; сондай-ақ, сіз жаңа функцияларды жазған кезде оларды кез-келген атаулар кеңістігіне нақты енгізе аласыз. Әрі қарай, егер сіздің кодыңыз қандай да бір атаулар кеңістігінде болса, ол тек сол атаулар кеңістігінің функцияларына, сондай — ақ глобалды атаулар кеңістігінің (сонымен қатар іс жүзінде ата-аналық атаулар кеңістігінің функциялары - өйткені атаулар кеңістігінің құрылымы ағаш тәрізді) функцияларына тікелей жүгіне алады.
     Егер сіз басқа атаулар кеңістігінен функцияны шақыруыңыз керек болса, онда сіз бұл функцияның алдында атаулар кеңістігінің атауын және қос нүктені анық жазуыңыз керек, мысалы, ``other`` атаулар кеңістігінен ``fun`` функциясы ``other::fun`` деп аталады.

     Мұның бәрі питондағы сияқты, егер сіз ``import math`` деп жазсаңыз, онда сіз квадрат түбір функциясын жай ``sqrt`` деп шақыра алмайсыз, ``math.sqrt`` деп жазуыңыз керек.

     Бұл өте қарапайым мақсатпен жасалады: кез-келген бағдарламалау тілі үшін көптеген кітапханалар бар және әр кітапханада көптеген мүмкіндіктер бар.
     Әрине, әр түрлі кітапханаларда бірдей атаумен функциялар болуы мүмкін, мысалы, файлдар кітапханасында файлды ашу үшін ``open`` функциясы болуы мүмкін, ал желімен жұмыс істеу үшін 
    кітапханада ``open`` функциясы болуы мүмкін, мысалы, кейбір сайттармен байланыс орнатуда да ``open`` атауымен функция болуы мүмкін.

     Сәйкесінше, егер сіздің бағдарламаңыз осы екі кітапханамен де жұмыс істеуі керек болса және сіз бағдарлама кодында ``open`` деп жазсаңыз, онда компилятор сізге қандай функция қажет 
    екенін түсінбеуі мүмкін. Бұл мәселені шешу үшін әр кітапхананың коды өзінің атаулар кеңістігіне орналастырылады, содан кейін атаулар кеңістігін нақты көрсете отырып, сіз компиляторға 
    қандай функция қажет екенін түсіндіре аласыз.

     Атап айтқанда, стандартты C библиотек кітапханасындағы барлық дерлік функциялар (әр түрлі қосымша кітапханалардан емес,атап айтқанда кез-келген компиляторға кіретін функциялар) ``std``
    атаулар кеңістігінде орналасқан. Тиісінше, егер сіз ``#include <iostream>`` деп жазсаңыз, сіз пернетақта мен экранмен жұмыс істеу мүмкіндігін қосқансыз, бірақ тиісті функциялар мен 
    айнымалыларға `std::` арқылы қол жеткізу керек(мысалы, ``std::cin``).
    
    ``using namespace`` сізге атаулар кеңістігінің атауын нақты білдірместен көрсетілген атаулар кеңістігіндегі функцияларды пайдалануға мүмкіндік береді. Атап айтқанда, 
    ``using namespace std;`` деп жазу арқылы сіз стандартты функцияларды ``std::`` префиксінсіз пайдалана аласыз.
    
     Маңызды бағдарламаларда ``using namespace`` қолдану ұсынылмайды, өйткені атауы бірдей бірнеше функциялар бойынша мәселелер туындайды. Бірақ біздің кішігірім бағдарламаларымызда функция атаулары туралы шатасуыңыз екіталай, сондықтан әдетте ``using namespace std;`` кодын жазуға болады. (Кейбір мәселе шығуы мүмкін; мысалы, менің есімде, кейбір компиляторларда ``std::y1`` функциясы бар. Егер сіз ``using namespace std;`` кодын жазсаңыз, айнымалыны ``y1`` деп атай алмайсыз. Бірақ бұл тек кейбір компиляторларда кездесетін сияқты, және біздің бағдарламаларымызда мұндай жағдайларда айнымалының атын өзгерту оңайырақ.)

     Айта кететін жайт, көптеген басқа тілдерде (*модуль* деген түсінік бар тілдерде), атаулар кеңістігі мен модуль екеуі бір мағына береді. Мысалы, питон тілінде ``import math`` деп бастасаңыз, ары қарай ``math.sqrt`` деп жаза аласыз немесе ``from math import *`` деп бастап, ары қарай тек ``sqrt`` деп қолдана бересіз. Бұл жердегі ``import math``  С++ -тағы ``#include`` кодының аналогы, ал ``from math import *`` болса,  ``#include`` пен ``using namespace`` қосылған түрінің аналогы. Сондықтан, басқа тілдерде атаулар кеңістігі деген жеке түсінік кездеспейді, атаулар кеңістігі деген ол қарапайым модульдар.

     «Атаулар кеңістігі» деген термин қызық көрінуі мүмкін, бұл негізі ағылшын тіліндегі namespace сөзінен құралған калька, бірақ мағынасы түсінікті: бұл кейбір «кеңістік», «атаулар» орналасқан аумақ - функциялардың атауы, айнымалылар, типтер және т.б.
     Сәйкесінше, С++-тегі барлық атаулар өзара қиылыспайтын кеңістіктер бойынша орналасқан. Және әрбір кеңістік «атаулар кеңістігі» деп аталады.

Келесі жол (ары қарай тексттер тек кодтар бойынша болады, азырақ ескертулермен)::

    int main() {

Бұл жол ешқандай аргументтерді қабылдамайтын және ``int`` түрінің мәнін қайтаратын "main" функциясын анықтайды (бұл бүтін сандар үшін ең стандартты деректер түрі).
Бұл Паскальдағы ``function main:integer`` немесе питондағы ``def main():`` жазбасының баламасы (тек питоннан айырмашылығы, C++ - да қайтару мәні қандай болатынын нақты көрсету керек, біздің жағдайда бұл ``int``).

C++ - да, питоннан, Паскальдан және басқа да көптеген тілдерден айырмашылығы, кез-келген функциядан тыс жазылатын «бағдарламаның негізгі коды» деген ұғым жоқ.
C++ - дағы кез — келген орындалатын код қандай-да бір функцияның бөлігі болуы керек, ал бағдарламаның ең негізгі коды функцияның ішінде арнайы ``main`` атауымен жазылуы керек. Басқаша айтқанда, бағдарламаны C++-да бастаған кезде ``main`` деп аталатын функция автоматты түрде іске қосылады. Ол C++ - дағы кез-келген бағдарламада болуы керек, ол дәл біреу болуы керек және жоғарыда айтылғандай, ешқандай параметрлерді қабылдамауы керек (бірақ нақты параметрлерді қабылдай алатын опция бар-олар команда жолының параметрлерін беру үшін қолданылады — бірақ бұл сізге әлі қажет емес), және ``int`` қайтару керек (бұл туралы кейін сөйлесейік).

Жалпы, біз төменде функциялардың синтаксисі туралы айтатын боламыз, бірақ әзірге бағдарламаның негізгі коды осындай жолдан басталуы керек екенін есте сақтаңыз.

Мұндағы ашылатын пішінді жақша ``{`` функция кодының басталғанын көрсетеді. Ол сәйкес жабылатын пішінді жақшаға ``}`` дейін жалғасады (Паскаль тіліндегі ``begin``/``end`` сияқты; Python-дан айырмашылығы, C++ тіліндегі шегініс (tab) компилятор үшін маңызды емес).

::

    int a, b;

Бұл жол ``int`` түріндегі екі айнымалыны жариялайды, айнымалылар ``a`` және ``b`` деп аталады. Еске сала кетейін, ``int`` бүтін сандар үшін ең көп қолданылатын деректер түрі болып табылады; біз төменде бар деректер түрлері туралы көбірек айтатын боламыз. Бұл жазбамен ``a`` және ``b`` айнымалыларында нақты не жазылатынына кепілдік жоқ екенін ескеру маңызды. Олар кез келген мәнді қамтуы мүмкін; атап айтқанда, онда нөлдер жазылатынына мүлдем кепілдік берілмейді. Кейбір компиляторлар барлық айнымалы мәндерді нөлге қояды, бірақ басқаларында олай емес.
Іс жүзінде, кейбір жағдайларда инициализацияланбаған айнымалыны пайдалану undefined behavior болып табылады (төменде қараңыз), яғни бұл жағдайда бағдарлама өзін ұнататын кез келген жолмен әрекет ете алады.
Сондықтан, әрқашан, егер айнымалы мәндерді инициализациялау маңызды болса, олардың неге тең болуы керектігін нақты көрсетіңіз (бұл туралы төменде толығырақ). Біздің жағдайда бұл әлі маңызды емес, өйткені біз бұл айнымалыларды пернетақтадан енгіземіз.

::

    cin >> a >> b;

Пернетақтадан ``a`` және ``b`` айнымалы мәндерін енгізіңіз. Өте ерекше синтаксиске назар аударыңыз. ``cin`` айнымалысы пернетақтадан енгізу ағыны деп аталады (консольдық кірістен), екі «үлкен» белгісі деректер ағынының бағытын көрсететін көрсеткішке ұқсайды: ``cin``-ден ``a``  және `` b`` -ға дейін.
Осылайша айнымалылардың кез келген санын енгізуге болады, жай ғана ``>>`` және айнымалының атын қосыңыз.

C++ - да пернетақтаны енгізу бірінші жуықтауда маңызды емес, сандар бос орындармен немесе жол аудармаларымен бөлінеді.
Жоғарыда жазылғандай жазу пернетақтадағы санды есептейді, егер олар бар болса, алдымен қосымша бос орындарды немесе жол аудармаларын өткізіп жібереді, содан кейін тағы бір санды есептейді, тағы да оның алдындағы бос орындар мен жол аудармаларын өткізіп жібереді.

.. note ::

    Бұл «ағынды» енгізу, әрине, Python-ның ``input()`` арқылы енгізуіне қарағанда әлдеқайда ыңғайлы, мұнда әр жолға қанша сан енгізілгенін ойластыру керек. Python-да ағындық кірістің жоқтығы 
    таңқаларлық болуы мүмкін, бірақ шын мәнінде бұл таңқаларлық емес: нақты өмірде ағынды енгізу сирек қажет; Енгізілген деректерде бос орындармен немесе жол үзілімдерімен бөлінген сандар 
    болатындай жағдайлар - бұл олимпиадалардың ерекшеліктері және шынайы өмірде олар өте сирек кездеседі.

::

    int s = a + b;

Біз жаңа айнымалыны бастаймыз, ``s``, сонымен қатар ``int`` сияқты және оған бірден ``a`` және ``b`` сандарының қосындысын жазамыз. Айнымалыны құру кезінде оған қажетті мәнді бірден жазуға болады. ``=`` белгісінің оң жағында, әрине, кез-келген өрнек болуы мүмкін, оның ішінде егер бізге қандай сан қажет екенін бірден білсек соны ензігуге болады (яғни, мысалы, ``int cnt = 0;`` деп жазуға болады, егер айнымалыға нөлді жазғымыз келсе).

Жалпы алғанда, C++ тілінде пернетақтадан енгізу сияқты ерекше жағдайларды қоспағанда, барлық айнымалы мәндерді жасалған кезде бірден инициализациялау ұсынылады.
Атап айтқанда, айнымалы мәндерді қажет болған сәтте ғана жасау ұсынылады.
Паскаль тілінен ауысатын адамдар барлық қажетті айнымалыларды функцияның басында бірден жариялауды ұнатады - бұл қажет емес.
Әрбір айнымалыны қажет болғанда ғана жариялаңыз; мысалы, мұнда біз ``s`` айнымалысын қажет болғанда ғана жариялаймыз. Сонымен қатар, көбінесе мұндай жағдайларда біз бірден мағыналы мәнді айнымалыға жаза аламыз, ал егер оны функцияның басында жариялаған болсақ,
онда бұл мүмкін емес еді (біздің мысалда функцияның басында ``s`` айнымалысын жарияласақ, онда алдымен ол жерге мағыналы ештеңе жаза алмадық).

::

        cout << s << endl;

Жауапты экранда көрсетеміз. Мұнда ``cout`` консоль шығысына жауапты айнымалы болып табылады және бұл жолы таңбалар қолданылғаннан азырақ, сонымен қатар деректер қозғалысының бағытын анық көрсетеді: ``s``-ден ``cout``-ға дейін. Әрі қарай ``endl`` шығарамыз - бұл арнайы айнымалы, оның ``cout`` ішіндегі шығысы жол арнасына әкеледі. (Шын мәнінде, мен төменде жазамын, сіз ``endl`` қолданбауыңыз керек, ол өте баяу. Бірақ жаңадан бастағандар үшін және жалпы алғанда шығыс деректерінің көлемі өте үлкен емес бағдарламаларда ``endl`` жазуға болады. ) (Сонымен қатар, осы нақты бағдарламада жол арнасы ерекше қажет емес екенін атап өтейін, өйткені біз бәрібір басқа деректерді шығармаймыз. Егер бізге басқа нәрсені шығаруды жалғастыру қажет болса, онда иә, жол арнасының мағынасы болуы мүмкін, әйтпесе бұл қажет емес.)

::

        return 0;

Басқа тілдердегідей, ``return`` командасы функцияны тоқтатуды және көрсетілген мәнді шақырылған жерге қайтаруды білдіреді.
Бірақ бұл жерде біз ``main`` негізгі функциясындамыз, сондықтан бұл команда бағдарламаны аяқтайды.

Ал мұндағы нөл бүкіл бағдарламаның *қайтару коды* (exit code) болады.
Тұтастай алғанда, барлық операциялық жүйелерде жалпы қабылданған конвенция бар, әрбір іске қосылған бағдарлама операциялық жүйеге арнайы нөмірді қайтарады - *қайтару коды* деп аталады, ол бағдарламаның сәтті аяқталғанын немесе аяқталмағанын көрсетеді, сондықтан кім іске қосты бұл бағдарлама (ОЖ өзі немесе кез келген басқа бағдарламалар) қоңыраудың сәтті болғанын түсіне алады. Сондай-ақ, жалпы қабылданған конвенцияға сәйкес, нөлге тең қайтару коды бағдарламаның сәтті аяқталғанын білдіреді, ал нөлдік емес код қандай да бір қатенің орын алғанын білдіреді.

Мысалы, Code::Blocks қайтару кодын - exit code - аяқталғаннан кейін бағдарлама терезесінде жазады.
Сол сияқты, тестілеу жүйелері бағдарламаның қайтару кодын талдайды және егер ол нөлге тең болмаса, сынақ нәтижесін «орындалу уақытының қатесі» немесе «нөлдік емес қайтару коды» (екеуі бірдей нәрсе) көрсетеді.

C++ тіліндегі ``main`` функциядағы ``return`` командасы сіздің бағдарламаңыздың қай қайтару кодын көрсету керектігін көрсетеді.
Біз ``қайтару 0`` деп жазамыз: бұл бағдарламаның сәтті аяқталғанын білдіреді.
Мысалы, ``қайтару 1`` деп жаза аламыз, содан кейін бағдарламаны басқарған адам бірдеңе дұрыс емес екенін түсінеді.
Атап айтқанда, егер тестілеу жүйесіндегі кейбір тестте ``main`` ``return 1``-мен аяқталса, онда сіз «орындалу қатесі» немесе «нөлдік емес қайтару коды» сияқты тест нәтижесін аласыз.

Басқа бағдарламалау тілдерінде қайтару коды түсінігі, әрине, бар, бірақ, мысалы, Python және Паскальда, егер орындалу негізгі кодтың соңына сәтті жеткен болса, онда қайтару коды нөлге тең болады деп есептеледі. Бірақ кейде сіз қайтару кодын нақты көрсету қажеттілігіне тап болған шығарсыз - мысалы, ``sys.exit(0)`` конструкциясында нөл бағдарламаны тоқтату керек қайтару коды болып табылады.

Дәл осы себепті ``main`` функциясы ``int`` түрін қайтаруы керек, сондықтан функция тақырыбы ``int main() {`` деп көрінеді.

.. note ::

    Шындығында, енді ``main`` функциясында ``return 0`` жазудың қажеті жоқ - содан кейін ол нөлді қайтарады.
     (Бірақ функция әлі де ''void'' емес, ''int'' ретінде анықталуы керек.)
     Бірақ әрқашан ``return 0`` деп нақты жазған дұрыс, атап айтқанда, егер сіз ``return 0`` деп нақты жазбасаңыз, көптеген ескі компиляторлар кездейсоқ қайтару кодын жасай алады.
     ``int`` қайтаратын басқа функцияларда ``return`` жазбау мүмкін емес.

::

    }

Ақырында, бағдарламаның соңғы жолы ``main`` функция кодының аяқталғанын көрсететін жабылатын пішінді жақша болып табылады. Бұл паскальдың ``end`` сөзіне ұқсас.


Синтаксистің негізгі принциптері
----------------------------

C++ бағдарламасы (басқа тілдердегі сияқты) командалар тізбегі. Көптеген командалар нүктелі үтірмен аяқталуы керек.

Бағдарламаның құрылымы пішінді жақшалармен қалыптасады, яғни функция блоктары, егер блоктар, циклдар және т.б. пішінді жақшалар арқылы көрсетіледі.
Python-дан айырмашылығы, C++ бағдарламасындағы шегініс (tab) компилятор үшін мағынасы жоқ. Компилятордың көзқарасы бойынша сіз қалағаныңызша шегініс жасай аласыз және әдетте бағдарламаны қалағаныңызша жолдарға бөле аласыз және т.б. (Кейбір ерекшеліктер бар, мысалы, компилятор директивалары, жоғарыдан қараңыз және бір жолды түсініктемелер, төменде қараңыз.) Дегенмен, әрине, шегіністерді Python тілінде орнатылғандай орнату ұсынылады (және факт, кез келген басқа бағдарламалау тілінде ) - бағдарламаны оқуды жеңілдету үшін.

C++ тілінде түсініктемелердің екі түрі бар: бір жолды - олар қатардағы екі қиғаш сызықтан (``//``) басталып, жолдың соңына дейін созылады, ал көп жолды - олар ``/*`` таңбасынан басталады және ``*/`` тармағынан аяқталады. Мысалы::

    #include <iostream>

    using namespace std;

    int main() {
        int a, b;  // бұл түсініктеме
        cin >> a >> b;  /* және
        мынау
        да
        түсініктеме */ int s = a + b;
        cout << s << endl;
        return 0;
    }

C++ тілі регистрге сезімтал (питон сияқты және Паскальдан айырмашылығы): бас әріптер мен кіші әріптер әр түрлі.
Қарапайым бағдарламаларда тек кішкентай әріптерді қолдану әдеттегідей. Үлкен әріптер әдетте түрлерде (сынып атауларында) және глобал тұрақтылар (константа) мен макростардың атауларында қолданылады, біздің бағдарламаларда сізге сирек қажет болады.

Айнымалылар негізінен функциялардың ішінде анықталады, бірақ *глобал* айнымалылар да анықталуы мүмкін - олар барлық функциялардан тыс анықталуы керек::

    #include <iostream>

    using namespace std;

    int a, b;

    int main() {
        cin >> a >> b;  // тут теперь используются глобальные a и b
        int s = a + b;
        cout << s << endl;
        return 0;
    }

Глобал айнымалылар төменде анықталған барлық функцияларда (бағдарлама коды бойынша) айнымалылардың өзінде көрінетін болады.
Жалпы алғанда, глобал айнымалыларды пайдалану ұсынылмайды, бірақ қарапайым бағдарламаларда егер олар әртүрлі функцияларда шынымен қажет болса, оларды пайдалануға болады (мысалы, егер сіз тереңірек іздеуді жазсаңыз, онда графикті глобал етіп жасауға болады. айнымалы).

Бүтін деректер түрлері және толып кету
----------------------------------------

Питоннан айырмашылығы, онда түрі бүтін сандар үшін бір және ол қалағанынша сақтай алады үлкен сандар (қажет болған жағдайда ұзын арифметикаға ауысу), С++ -да бүтін сандар үшін әр түрлі типтер бар және әрқайсысының рұқсат етілген мәндер аралығының өз шекаралары бар. Бұл жағдайда түрлер қатаң анықталмаған; бір типтегі рұқсат етілген интервал әр түрлі компиляторларда немесе тіпті бір компилятордың әр түрлі нұсқаларында әр түрлі болуы мүмкін.

Мен мұнда барлық түрлерін тізімдемеймін, олар өте көп, мен сіз қолданатын негізгілерін ғана тізімдеймін:

-  **int** — негізгі, ең көп қолданылатын түрі.:math:`-2^{31}`-дан :math:`2^{31}-1` дейін немесе (компиляторға және опцияларға байланысты) :math:`-2^{63}`-дан :math:`2^{63}-1` дейінгі сандарды сақтайды, сәйкесінше 4 немесе 8 байт алады.
-  **unsigned int** (Бос орынмен осылай жазылған!), немесе қысқаша **unsigned** — *белгіленбеген* (санның белгісін сақтамайды, оның орнына сан мәнінің қосымша битін сақтайды) 
    int-қа балама, 0-ден :math:`2^{32}-1` дейін немесе :math:`2^{64}-1` дейінгі сандарды сақтайды, сәйкесінше 4 немесе 8 байт алады (int сияқты).
-  **long long int**, немесе қысқаша **long long** — :math:`-2^{63}`-дан :math:`2^{63}-1` дейінгі сандарды сақтайды, 8 байт алады.
-  **unsigned long long int**, немесе қысқаша **unsigned long long** — long long-тың белгіленбеген баламасы, 0-ден :math:`2^{64}-1` дейінгі сандарды сақтайды, 8 байт алады.
-  **size_t** — бұл кез келген жарамды деректер түрінің (массивтерді қоса алғанда) өлшемі (байтпен) дәл осы түрге сәйкес келетініне кепілдік беретін жеткілікті үлкен, қол қойылмаған түр (бұл мүлдем нақты анықтама емес, бірақ мағынаға жақын) . Яғни, `` size_t`` кез келген басқа айнымалы иеленетін байттардың санын сақтауға кепілдік береді. Әдетте бұл unsigned баламасы немесе unsigned long long баламасы. Ол көбінесе кейбір стандартты функциялар нысанның өлшемін, массивтегі элементтердің санын немесе сол сияқтыларды қайтаратын жағдайларда қолданылады. (өйткені, жоғарыдағы анықтамаға сәйкес, бұл өлшем міндетті түрде size_t-ге сәйкес келеді, бірақ ол, мысалы, int-ге сәйкес келмеуі мүмкін). Ең қарапайым жағдайларда сіз бұл түрді өзіңіз қолданбайсыз, бірақ оны стандартты функциялардың сипаттамаларында көресіз.


.. note ::

    Жалпы айтқанда, компиляторлар немесе компиляция опциялары болуы мүмкін, онда бұл типтер одан да көп болады — жадтың мағынасында және сәйкесінше мәндер ауқымында. Бірақ іс жүзінде қазір 
    мұндай компиляторлар жоқ. Сондай-ақ, жалпы айтқанда,  ``int`` және сәйкесінше  ``unsigned`` аз болуы мүмкін, мысалы, 2 байтты алады және тиісті мәндер диапазонына ие болады, бірақ 
    компиляторларда толыққанды компьютерлер үшін (микропроцессорлар үшін емес, т.б.) сіз оны кездестіре алмайсыз.
    Айтпақшы, әрине, бекітілген компилятордың бекітілген опцияларында барлық түрлердің өлшемдері бекітілген, яғни бағдарламада екі  ``int`` айнымалысын жарияладыңыз, олардың бірі 4 
    байт, екіншісі 8 байт болуы; немесе сіз бағдарламаны құрастырған болсаңыз, сізде  ``int`` 4 байт болды, содан кейін ештеңені өзгертпестен, бірдей компилятормен бірдей опциялармен қайта 
    құрастырылып 8 байт шығуы мүмкін емес.

C цел-дағы бүтін типтердің маңызды ерекшелігі (және кез-келген басқа тілде, бірақ питонда емес)
**толып кету* * болып табылады. Егер сіз айнымалы мәнді оның түрінің рұқсат етілген диапазонынан тыс сақтауға тырыссаңыз, оның орнына рұқсат етілген диапазонға жататын басқа мән сақталады. Сонымен қатар, C++ - да ешқандай қате болмайды, тек үнсіз қате жауап аласыз.

Алдыңғы абзацтағы "сақтау" сөзі сіз осындай санды тікелей жазуға тырысқан жағдайларды (мысалы, ``int x = 12345678901234567890;``) және кез-келген есептеудің нәтижесін сақтайтын жағдайларды білдіреді (``int a = 1000000000; int b = a * a;``) және деректерді енгізу жағдайларына және т.б. тәжірибе жасап көріңіз және оның қалай жұмыс істейтінін біле аласыз.

Сондықтан, әрдайым бүтін деректер түрлерімен жұмыс жасағанда, толып кету қаупі туралы ұмытпаңыз. Әрқашан бір немесе басқа айнымалыда қандай максималды мән пайда болуы мүмкін екенін бағалаңыз және оның түрге сәйкес келетінін тексеріңіз. Егер ол 4 байтты int - ге сәйкес келмесе, ``long long`` айнымалысын жасаған дұрыс (жалпы айтқанда, барлық айнымалыларды ``long long`` жасауға ешкім кедергі жасамайды, бірақ содан кейін сіз кейбір үлкен массивтердің жад шектеулерінен өтпеу қаупін тудырасыз, сонымен қатар ``long long`` да толып кетуі мүмкін).
Егер сіз жауаптың тіпті ``long long``-қа сәйкес келмейтінін көрсеңіз, онда сіз қазірдің өзінде ойлануыңыз керек. Мүмкін, белгілі бір компиляторда 16 биттік бүтін сан түрі бар (``int128_t`` немесе ``__int128`` сияқты), бірақ бұл әрдайым бола бермейді, сонымен қатар ол толып кетуі мүмкін.
Немесе ұзын арифметиканы қолдану керек. Немесе мұндай Үлкен сандар пайда болмайтын басқа алгоритм ойлап табыңыз.

Белгілердің толып кетуінің жиі және өте айқын белгісі (``int`` және ``long long``) - бұл теріс сан болуы мүмкін емес жауап (мысалы, оң сандардың қосындысы) әлі де теріс болып шығады.
Егер сіз мұны бағдарламаңызда байқасаңыз-толып кету жағын іздеңіз.

Сондай-ақ, қол қойылмаған түрлерді қажетсіз пайдалануды ұсынбаймын. Олардағы өте жиі кездесетін қателік - бұл төмен, төмен қарай толып кету деп аталатын: мысалы, 0-ден 1-ді алып тастауға тырыссаңыз, нәтиже -1 болмайды (өйткені таңбасыз түрлер теріс сандарды сақтай алмайды), бірақ өте үлкен сан. Атап айтқанда, әдеттегі қате - кейбір массивтің немесе жолдың ұзындығынан біреуін алып тастау: бұл ұзындықтар әдетте ``size_t`` өлшемімен өлшенетіндіктен, жол ұзындығы нөлге тең болса, толып кету орын алады.
Алдымен ұзындықты ``int`` ішінде сақтау дұрыс, содан кейін 1-ді алып тастау немесе түрлерін беру керек, төменде қараңыз.

.. note ::

    Толып кетудің нәтижесі қандай? Белгіленбеген түрлерді толтырған кезде (``unsigned``, ``unsigned long long``, ``size_t`` және т.б.), 
    :math:`2^x`-ке бөлгендегі қалдықтың модульі алынады, мұнда :math:`x ` – осы деректер түріндегі биттердің саны (жоғарыдағы түрлер үшін 32 немесе 64). 
    Мағынасы қарапайым – белгіленбеген түрі бар кез келген операциялар кезінде ең аз маңызды :math:`x` биттері ғана сақталады және барлық қосымша биттер жойылады.

    Белгісі бар типтердің толып кетуі анықталмаған. Бұл undefined behavior деп аталады (төменде қараңыз) - егер бұл өте қарапайым болса, 
    онда белгілердің толып кетуінің салдары, соның ішінде `int`, тіпті бағдарламаның құлауын қоса алғанда, кез келген нәрсе болуы мүмкін.

Мен сондай-ақ типті келтіру туралы айтайын («келтіру» сөзінен – сіз бір түрді екіншісіне ауыстырасыз, яғни басқа түрге түрлендіресіз; оны сондай-ақ ағылшынша cast «каст» дейді).
Мән түрін жаңа түрдегі айнымалы мәнде сақтау арқылы әрқашан түрлендіруге болады::

    unsigned x = ....;
    int y = x;  // x unsigned болды және оны int-те сақтадық
    cout << y - 1;  // енді толып кетуден қорықпай 1-ді шегеруге болады

Бірақ артық айнымалыларды бастамау үшін Сіз қажетті түрге ие болатын өрнекті жаза аласыз.
C++ стиліндегі жазбаның толық пішіні келесідей: ``static_cast<int>(x)``, мұнда бұрыштық жақшаларда (тағы да, бұл тек қана үлкен емес таңбалар) қай типті көрсеткіңіз келетінін көрсетесіз, ал жақша ішінде - шығарғыңыз келетін айнымалы мәнді бересіз.
Бұл жазба * өрнек*, яғни оны бір жерде сақтауға немесе басқа өрнектерде қолдануға болады.
Мысалы, келесідей::

    unsigned x = ...;
    cout << static_cast<int>(x) - 1;  // алдымен int-ке түрлендірілді, содан кейін 1 шегерілді

Сондай-ақ C стиліндегі белгі бар: ``(int)x``, мысалы

::

    unsigned x = ...;
    cout << (int)x - 1;  // алдымен int-ке түрлендірілді, содан кейін 1 шегерілді

Бірінші жуықтау үшін бұл бірдей, бірақ күрделі түрлерде ``static_cast`` қолданған дұрыс.

Әрине, ``static_cast`` тек бүтін сан түрлеріне қатысты емес; сіз әртүрлі типтерді көрсете аласыз, 
мысалы, нақты түрі: ``static_cast<double>(x)`` (``double`` түрі үшін, төменде қараңыз).
Қандай түрлерге әкелуге болатыны туралы қатаң ережелер өте күрделі және әдетте өте қатал 
(мысалы, санды жолға түрлендіру немесе керісінше ``static_cast``  арқылы жұмыс істемейді), бірақ сіз тәжірибе жасап көре аласыз.

Арифметикалық амалдар
-----------------------

Қосу, алу және көбейту ``+``, ``-`` және ``*`` көмегімен басқа тілдердегідей орындалады, мұнда ерекше ештеңе жоқ. Көрсеткіштерге арналған арнайы оператор жоқ, циклды жазыңыз :) (немесе жағдайға байланысты жылдам дәрежеге шығару немесе ``pow``).

Бірақ бөлудің кейбір ерекшеліктері бар. Жартылай бөлікті ``/`` операторы, қалдығын ``%`` операторы қабылдайды, 
бірақ екі бүтін санды нақты алу үшін бөлудің тікелей жолы жоқ (яғни C++ тілінде ``/ `` — Python ` `//``, бірақ Python ``/`` аналогы жоқ).
Нақты санды бөлуді алу үшін сандардың кем дегенде біреуі нақты сан екеніне көз жеткізу керек.

Мысалы::

    int x = 10, y = 3;
    cout << x / y;  // 3-ті қайтарады
    cout << 1.0 * x / y;  // бөлінгішті нақты санға өзгерттік, жауабы 3.33333 шығады

Ерекше, бірақ өте маңызды жағдай - ``1/2`` жазбасы нөлді береді. 0.5 алу үшін, мысалы, ``1.0/2`` (немесе тікелей ``0.5``, әрине) жазу керек.

Бөлудің екінші ерекшелігі-теріс сандарды өңдеу. Егер сіз теріс санды оң санға бөлудің қалдығын алсаңыз, онда қалдық теріс болады. Бұл қисынды болып көрінуі мүмкін, қарама-қайшы болып көрінуі мүмкін (және бұл шын мәнінде қисынсыз), бірақ питонда олай емес және көптеген жағдайларда сізге кедергі болады. Бұл мәселені айналып өтудің стандартты тәсілі - ``(a%b+b)%b`` деп жазу, яғни бір қалдықты алғаннан кейін ``b`` қосу (нақты оң Сан алу үшін) және қалдықты қайтадан алу. Немесе ``if`` деп жазыңыз. Сол сияқты, теріс санды оңға бөлудің толық емес бөлігін есептеу кезінде жауап сіз күткеннен 1-ге өзгеруі мүмкін.

Егер бөлгіш теріс сан болса, онда ол әлі де қиын болуы мүмкін.

.. note ::

    Толығырақ. Қалдықпен бөлудің анықтамасы өте қарапайым: бүтін санды бөлу :math:`A` натурал санға :math:`B` — бұл екі адам санын табу
    :math:`R` (толық емес бөлшек) және: math:`Q '(қалдық), бұл: math: `A = R \cdot B + Q`, содан кейін келесі талаптарды қою керек :math:` Q` (немесе :math:`R').

    Классикалық анықтама келесі шартты орындауды талап етеді :math:`0\leq Q<B`, яғни қалдық теріс емес және :math:`B` - дан аз .
    Питон дәл осы анықтаманы ұстанады.  Мысалы, ``(-10) // 3 = -4`` және ``(-10) % 3 == 2`` (себебі ``-10 == 3 * (-4) + 2``).
    Бұл біртүрлі көрінуі мүмкін (``(-10) // 3`` шешімі ``-3`` боп көрінуі мүмкін), бірақ бұл шын мәнінде қисынды.

    Бірақ барлық заманауи процессорлар басқаша ойлайды (шамасы, бұл тарихи түрде болған, ал қазір процессорлардың бар мінез-құлқын өзгерту мүмкін емес).
    Егер :math:`A>0` болса, онда олар бірдей анықтаманы қолданады. Ал егер :math:`A<0` болса, онда :math:`-B<Q\leq 0` осы өрнекті орындау керек болады.
    Бұл анықтамамен ``(-10) // 3 == -3`` және ``(-10) % 3 == -1`` шығады. Нәтижесінде бәрібір :math:`A = R \cdot B + Q` болады, сол үшін
    :math:`Q` бұл нұсқада :math:`B` -дан кіші алдыңғы нұсқаға қарағанда (-1  2-нің орнына егер ``B==3`` мысалда болса), ал :math:`R` бірлікке үлкен,
    бірақ бұл әлі де ыңғайсыз.

    Python бұл әрекетке арнайы жеңілдіктер жасайды, ал C++ (және көптеген басқа тілдер) процессор қайтарған нәтижені жай ғана пайдаланады.

    Мұның бәрі бөлгіш (:math:`B`) оң болғанда болды. Теріс бөлгішпен бәрі әдетте күрделірек.

Тағайындаулар, auto және ++
-----------------------

Тағайындау жалғыз теңдік арқылы жасалады::

    s = a + b;

(Бұл сізде жаңа мәнді жазғыңыз келетін ``s`` айнымалысы бар деп болжайды.)

Питондағыдай қысқартылған тағайындау операторлары да бар: ``+=``, ``-=``, ``*=``, ``/=``, ``%=``.

Сондай-ақ, тағайындауларды айнымалыны жариялау кезінде бірден қолдануға болатынын көрдік::

    int a = 10;

Бұл жағдайда белгілі бір түрдің орнына арнайы ``auto`` сөзін қолдануға болады, ол «өрнектің оң жағындағы түрді пайдалану» дегенді білдіреді (бұл тек C++11 тілінде пайда болды)::

    int a, b;
    ...
    auto c = a + b;  // a+b өрнек түрі int, сондықтан с айнымалысы да int

``auto a = 10`` белгісі өте анық емес (10 санының қай түрі - int? unsigned? long long?..), сондықтан оны қолданбау керек.
Бірақ оң жақта күрделі өрнек болса, онда ``auto`` қолдануға әбден болады.

Сондай-ақ айнымалыны 1-ге арттыру немесе азайтуды білдіретін ``++`` және ``--`` арнайы конструкциялары бар:

    int a = 10;
    a++;  // a-ны 1-ге арттырсақ, a == 11 шығады
    a--;  // 1-ге азайту арқылы 10-ға қайтарамыз

Шын мәнінде, бұл операторларды жазудың екі нұсқасы бар: ``a++`` және ``++a`` және сол сияқты ``--`` түрінде де.
Екеуі де ``a`` мәнін бір-біріне арттырады, бірақ қайтару мәні бойынша ерекшеленеді.
(ол ``b = a++`` сияқты бірдеңе жазған болсаңыз немесе мысалы, ``foo(a++)`` функциясын шақырсаңыз пайдаланылады).
``a++`` жазу кезінде қайтару мәні ескі ``a`` мәніне тең болады (мысалы, алдымен ``a`` мәнін есте сақтаңыз, содан кейін оны 1-ге көбейтіңіз), ``++a`` болғанда  - жаңа мән (бірінші ұлғайту, содан кейін ``a`` мәнін пайдалану сияқты) және сол сияқты ``--`` үшін де::

    int a = 10;
    int b = a++;  // b 10-ға тең болады
    int c = --a;  // с да 10-ға тең болады

Бірақ жалпы алғанда, ``++`` және ``--`` операторларының нәтижесін пайдалану жаман тәжірибе, оны жасамаңыз. ``a++`` бөлек команда ретінде жазыңыз,
содан кейін ешқандай проблемалар болмайды.

Түбірді табу ``sqrt`` көмегімен есептеледі, ол үшін ``cmath`` тақырып файлын қосу керек (``#include <cmath>``).
Модуль ``abs`` көмегімен есептеледі.

Кіріс-шығыс
----------

Жоғарыда көргеніміздей, пернетақтадан енгізу ``cin`` нысаны арқылы, экран шығысы ``cout`` арқылы жүзеге асырылады::

    #include <iostream>

    .....

    int a, b;
    cin >> a >> b;
    cout << a + b;

Сонымен қатар, мұндай оқу автоматты түрде қосымша бос орындарды өткізіп жібереді және жаңа жолдарға өтеді, сондықтан екі санның бір жолда немесе басқаларында болуы маңызды емес. Егер бұл сіз үшін маңызды болса (мысалы, деректерді тек бір жолдан оқу керек), онда ол күрделірек; ең оңай жолы - ``stringstream`` пайдалану, жолдар туралы бөлімде төменде қараңыз.

Шығару кезінде жолды беру ``endl`` жазу арқылы жүзеге асырылады немесе арнайы таңбаны немесе ``'\n'`` немесе ``"\n"`` жолын басып шығаруға болады (бұл жағдайда тырнақшалар немесе апострофтар қолданылғаны маңызды емес, бірақ жалпы жолдар мен белгілер туралы төменде қараңыз).

``cout`` айнымалылар арасына бос орындар енгізбейтінін ескеріңіз (Python-ның ``print``-інен айырмашылығы). Қажет болса, оларды өзіңіз енгізіңіз. Сондай-ақ, кіріс деректерін бүтін санға арнайы түрлендіруді жазудың қажеті жоқ екенін ескеріңіз (Python ``int()``-дан айырмашылығы). Айнымалы мәнді ``int`` деп жариялап қойсаңыз жеткілікті.

Жоғарыда «C++ стилі» енгізу/шығару сипатталады. С стилінде енгізу/шығару ``printf`` және ``scanf`` функциялары арқылы орындалады. Мен оларды сипаттамаймын, олар айтарлықтай күрделі, егер сіз оларды бір жерден көрсеңіз, таң қалмаңыз.

Шартты оператор (if) және логикалық операциялар
--------------------------------------------

Осылай жазылады::

    if (шарт) {
        код
    } else {
        код
    }

 ``else`` бөлімін жазбаса да болады (егер қажет болмаса)::


    if (шарт) {
        код
    }

Бұл жерде төмендегілер маңызды. Біріншіден, шарт жақшаға алынуы керек.Екіншіден, кодтың өзі пішінді жақшаға алынады; олар if ішінде қандай код бар екенін анықтайтындар. 
Егер ``if`` ішінде тек бір команда болса пішінді жақша жазудың қажеті жоқ. Бірақ команда өте қарапайым болмаса, бұл нұсқа ұсынылмайды.

Python тіліндегідей жағдайда сіз салыстыруларды пайдалана аласыз (``>``, ``>=``, ``<``, ``<=``, ``==``, ``!=``), салыстыру қос теңдік арқылы жасалатынын ескеріңіз (шын мәнінде, Python тіліндегідей және Паскальдан өзгешелеу).

Мұндағы маңызды мәселе, егер сіз қос теңдіктің орнына бір теңдік жазсаңыз, C++ қате жібермейді::

    if (a = b) {...}

бірақ бұл енді салыстыру емес, бұл тағайындау! сондықтан ол сіз ойлағандай жұмыс істемейді. Бұл өте жиі кездесетін қате, әсіресе Паскальдан ауысатындар арасында.
Python бұл жағдайда қате жібереді, бірақ C++ та олай емес.

Логикалық амалдар былай жазылады: and — ``&&``, or — ``||``, not — ``!``. Мысалы::

    if ((year % 400 == 0) || (year % 4 == 0 && !(year % 100 == 0)))

(әрине, былай да жазса болады ``year % 100 != 0``).

C++ тілінде ``elif`` конструкциясы жоқ. Бірақ бұл қажет емес - сіз жай ғана ``else if`` деп жаза аласыз::

    if (...) {
        ...
    } else if (...) {
        ...
    } else if (...) {
        ...
    } else {
        ...
    }

Python-да сіз оны осылай жаза алмайсыз, себебі әрбір ``else``/``if`` шегіністерді көбейтуді талап етеді және бірнеше шегіністер пайда болады. 
Бірақ C++ тілінде шегініске қатаң талаптар жоқ, сондықтан оны дәл осылай жазуға әбден болады.

Циклдер
-----

``while`` циклі сіз күткендей жазылған:

    while (шарт) {
        код
    }

``if`` сияқты, мұнда да шартты жақшаға алу керек, ал цикл денесі пішінді жақшада, ерекшелік — егер цикл денесі бір командадан тұрса, жақшаларды қоймаса болмайды (бірақ бәрібір ұсынылады).
``while`` циклі басқа тілдердегідей жұмыс істейді.

Бірақ C++ тілінде «for» циклі жазылған және әдеттен тыс жұмыс істейді. Ең қарапайым жағдайда ол былай жазылады:

    for (int i = 0; i < n; i++) {
        код
    }

Бұл Python-ның ``for i in range(n):`` эквиваленті - ``i`` айнымалысы 0-ден бастап ``n``-ға дейін (қоспағанда) барлық мәндер арқылы өтеді.

Жалпы, ``for`` тақырыбы нүктелі үтірмен бөлінген үш бөліктен тұрады. Бірінші бөлім (жоғарыдағы мысалдағы ``int i = 0``) цикл алдында не істеу керек (бұл жағдайда ``i`` айнымалысын жариялаңыз және сол жерге нөлді жазыңыз).
Екінші бөлік (``i < n``) циклды жалғастыру шарты болып табылады: бұл шарт циклдің ең бірінші итерациясына дейін және әрбір итерациядан кейін тексеріледі және шарт жалған болған кезде циклдің орындалуы аяқталады. (while шартына ұқсас).
Үшінші бөлік (``i++``) - шартты тексермес бұрын әрбір итерациядан кейін не істеу керек екені жазылады.

Яғни, жоғарыдағы жазба мынаны білдіреді: ``i`` айнымалысын бастаңыз, нөлді жазыңыз, содан кейін ``i<n`` рас екенін тексеріңіз, егер солай болса, цикл денесін орындаңыз, содан кейін ``i++`` жасаңыз, қайтадан ``i<n`` тексеріңіз, егер әлі де орындалса, қайтадан орындаңыз код және ``i++`` жасаңыз және т.б., келесі сәтте ``i>=n`` болғанға дейін.

Мысалдар::

    for (int i = n - 1; i >= 0; i--)  // кері цикл
    for (int i = 0; i < n; i+= 2)  // 2-қадаммен цикл
    for (int i = 0; !found && i < n; i++)  // found true немесе i >= n болғанда цикл аяқталады
    for (int i = 1; i < n; i *= 2)  // екі дәрежелі цикл

Яғни, шын мәнінде, C++ тіліндегі ``for`` циклдің өте күшті түрі болып табылады, тіпті әдеттегі ``while`` ``for``-дың ерекше жағдайы болып табылады. Бірақ қандай да бір жолмен дәйекті түрде өзгеретін анық "цикл айнымалысы" бар жағдайларда ғана ``for`` пайдалану ұсынылады, содан кейін ``for`` тақырыбында сіз оны тек еске саласыз. Егер сізге күрделірек нәрсе керек болса, ``while`` -ды жазыңыз.


Сондай-ақ, цикл айнымалысы тікелей цикл тақырыбында жарияланатынын ескеріңіз.
Атап айтқанда, мұндай айнымалы циклден тыс көрінбейді - дұрыс, егер сіз ``for`` циклін жазып жатсаңыз, циклден кейін цикл айнымалысын пайдаланудың қажеті жоқ.
Сонымен қатар, бұл, мысалы, бірдей айнымалысы бар қатарға екі «for» циклін жазуға мүмкіндік береді,
Сонымен қатар, бұл айнымалылар бір типте болуы міндетті емес:
    for (int i = 0; i < n; i++) {
        код, мұндағы i -- int
    }
    // мұнда i айнымалысы мүлде жоқ
    for (unsigned int i = 1; i < m; i *= 2) {
        код, мұндағы i -- unsigned
    }

Есть еще одна форма цикла ``for``, которая появилась в C++11 — это так называемый range-based for. Это уже чистый аналог питоновского ``for ... in``,
который позволяет итерироваться не по ``range``, а по более-менее любому объекту (массиву, строке и т.п.). На C++ это пишется так::

    for (int i : v) {
        код
    }

здесь предполагается, что ``v`` — это массив ``int``'ов, и тогда ``i`` последовательно принимает все значения элементов этого массива.

В частности, тут часто удобно использовать ``auto``::

    for (auto i : v) {
        ...
    }

у переменной ``i`` получится такой же тип, как у элементов массива.

Команды ``break`` и ``continue`` есть и работают в точности так же, как в питоне и паскале; в частности, можно писать ``while (true)``
и далее в коде использовать ``break``.

Кроме того, есть еще цикл do-while с проверкой условия после итерации, я его не буду описывать (хотя там ничего сложного),
он бывает довольно редко нужен (точнее даже практически никогда, не случайно в питоне нет его эквивалента).

Массивы
-------

Массивы в C++ объявляются следующим образом::

    #include <vector>

    ....
    vector<int> v;

Это объявляет пустой (длины ноль) массив (также часто говорят «вектор», по названию типа), 
в котором будут храниться ``int``'ы. В угловых скобках можно написать и другой тип — соответственно, будет массив
элементов соответствующего типа. В частности, двумерный массив делается так: ``vector<vector<int>>`` — это массив, каждый элемент которого является массивом ``int``'ов.

(Конструкция ``>>`` в записи ``vector<vector<int>>`` — это особенность C++11. В более ранних стандартах запись ``>>`` 
однозначно воспринималась как оператор ввода данных, и для определения двумерного массива надо было писать
``vector<vector<int> >`` с пробелом.)

.. note ::

    Обратите внимание, что если вы не проинициализируете числовую переменную вроде ``int x;``, то её значение не определено и его нельзя использовать.
    Если же вы не проинициализировали C++-массив, а написали просто ``vector<int> v;``, то он гарантированно будет пустым.
    Аналогично работают и более сложные структуры данных в C++: строки, словари...

Можно сразу указать длину массива::

    vector<int> v(n);

это массив длины ``n``. Он на самом деле будет заполнен нулями, но лучше на это не полагаться, указывайте ноль явно 
(потому что есть ряд схожих конструкций, когда данные остаются не инициализированы). Чтобы явно указать, каким значением заполнить массив, 
это значение надо указать после длины::

    vector<int> v(n, 1);

это массив, заполненный единицами.

Также можно создать массив, явно перечислив его элементы в фигурных скобках::

    vector<int> v{-1, 0, 1};

— это массив длины 3 с элементами -1, 0, 1.

Двумерный массив, заполненный нулями, создается так::

    vector<vector<int>> v(n, vector<int>(m, 0));

Что здесь написано? Начало понятное: ``vector<vector<int>> v(n,`` — это массив массивов, длина внешнего массива равна ``n``.
А дальше написано, чему должен быть равен каждый элемент: ``vector<int>(m, 0)`` — это можно сказать безымянный массив длины ``m``, заполненный нулями.
Поскольку он указан как значение для элементов внешнего массива, то этот массив длины ``m`` раскопируют и заполнят им внешний массив длины ``n``.
Итого получается двумерный массив ``n x m``, заполненный нулями.

Аналогично можно создавать и многомерные массивы. Только в отличие от питона, в C++ все элементы одного массива
должны иметь один тип, нельзя сделать массив, в котором часть элементов будет числами, а часть массивами, и т.п.
(Но на самом деле обычно вам это и не нужно.)

Доступ к элементам массива осуществляется через квадратные скобки: ``v[i]``, для двумерного массива ``v[i][j]`` (тем, кто переходит с паскаля:
обратите внимание, что запись ``v[i,j]`` скомпилируется, но работать будет совсем не так, как вы хотите). Элементы массива индексируются начиная с нуля, как в питоне.
Отрицательной индексации, как в питоне, нет: запись ``v[-1]`` — это выход за пределы массива.

Выход за пределы массива в C++ не обязательно приводит к ошибке. Строго говоря, он может привести к чему угодно, в простейших случаях
будет выполняться просто работа с памятью за пределами массива, возможно, будут затерты какие-то другие нужные вам данные и т.п.,
если вы очень сильно вышли за пределы массива, то программа вылетит. Но строго говоря при выходе за пределы массива может произойти абсолютно что угодно, 
это называется undefined behavior, см. про это ниже.

На массивах доступно немного меньше операций, чем в питоне. Основное — это операции ``push_back`` (приписывает элемент к концу массива, аналог питоновского ``append``,
пишется ``v.push_back(x);``) и ``pop_back`` (удаляет последний элемент массива: ``v.pop_back();``). Также работает присваивание массивов (``v2 = v;``), причем,
в отличие от питона, при этом происходит реальное копирование массива: после этого ``v2`` и ``v`` — разные массивы, и изменения в одном не влияют на изменения в другом.
Также массивы можно сравнивать любыми операторами сравнения (``>``, ``<`` и т.д., в том числе ``==``). Оператор ``==`` проверяет, правда ли,
что два массива одинаковы, т.е. поэлементно равны; операторы сравнения больше-меньше сравнивают массивы лексикографически.
Длину массива можно узнать через ``v.size()``.

Есть также много других операций, но не надо их использовать, по крайней мере пока вы не понимаете, какая у них сложность.

Вводить и выводить массивы напрямую через ``>>`` и ``<<`` нельзя, надо всегда писать цикл
(но за счет потокового ввода, т.е. за счет того, что оператору ``>>`` все равно, разделяются
числа пробелами или переводами строки, ввод массива пишется довольно просто, особенно если вам заранее задано,
сколько в массиве будет элементов). 

Типичный пример: если вам сначала вводится количество элементов в массиве, а потом сам массив,
то это можно писать так::

    int n;
    cin >> n;
    vector v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i];
    }

Обратите внимание, что мы объявляем переменную ``v`` только тогда, когда она понадобилась,
и за счет этого можем сразу указать нужную длину массива. Конкретные значения элементам массива
в момент объявления переменной не указываем, потому что все равно будем их вводить с клавиатуры.

Прямого аналога питоновских срезов нет.

Помимо векторов (``vector``), существуют также так называемые сырые массивы. Они объявляются так::

    int a[10];
    // или
    int* a = new int[10];

Это массивы в стиле C; не надо их использовать.


Символы и строки
----------------

Символьный тип данных в C++ называется ``char``, символьные константы пишутся в одиночных апострофах (не кавычках!).

Довольно необычная особенность ``char`` — в отличие от питона и паскаля, в C++ char — это сразу *целочисленный тип*, 
с точки зрения компилятора он хранит целое число.
В C++ нет операций типа ``ord`` и ``char``, переводящих символ в его код и наоборот. В C++ символ и его код — это одно и то же. Вы можете
записать в переменную символ, а потом прибавить какое-нибудь число, или например вы можете вычесть два символа.

Примеры::

    char a = 'A';  // ок, все понятно, это так же, как в питоне и паскале
    a += 10;  // мы можем к char прибавить 10, это дает символ, чей код на 10 больше чем 'A'
    int diff = 'a' - 'A';  // мы можем вычитать два символа и получать int (а можно и char)
    char b = 'B';
    b += diff;  // получается 'b'
    int x = b;  // просто копируем значение в x — теперь в x код символа 'b'
    char z = '9';
    int value = z - '0';  // так можно из символа-цифры получить настоящее значение этой цифры

Говоря по-другому, символы в C++ — это просто другая запись чисел. Т.е. запись ``'A'`` и 65 — это практически одно и то же.

Единственное отличие ``char`` от других целочисленных типов — это ввод-вывод. При вводе и выводе переменных типа ``char`` выводятся соответствующие символы.
Во всем остальном переменные типа ``char`` ведут себя как числа, равные коду соответствующих символов. 

В частности, символы можно сравнивать через больше/меньше; поскольку символы — это числа, то сравнение выполняется совершенно естественно.
Символы можно использовать как индексы массивов (типа ``v['$']``), по ним можно делать циклы (``for (char ch = 'a'; ch <= 'z'; ch++)``) и т.д.

Но есть одна важная особенность типа ``char`` — это то, что он по умолчанию знаковый, signed, т.е. может хранить и отрицательные числа.
Его диапазон по умолчанию от -128 до 127. Получается, что символы из первой половины ascii-таблицы имеют корректные положительные коды,
а символы из второй половины — отрицательные. Это нередко может мешать, но легко решается работой с ``unsigned char``. Вы можете просто скопировать значение в ``unsigned char``::

    char x;
    cin >> x;
    unsigned char xx = x;  // теперь xx содержит верный код от 0 до 255

или можете воспользоваться приведением типов, т.е. явно сконвертировать в ``unsigned char``::

    char x;
    cin >> x;
    v[static_cast<unsigned char>(x)] = ...
    // ну или вариант в стиле C
    v[(unsigned char)x] = ...

Строки хранятся в переменных типа ``string``, строковые константы задаются в кавычках (не в апострофах!), для экранирования
символов (кавычек и т.п.) используется обратный слеш::

    #include <string>
    
    ...
    string s = "Test";
    string s2 = "Quote: \", slash: \\";

Как и в других языках, строка — это массив, элементами которого являются символы, соответственно, со строкой доступны те же операции, что и с массивом:
``size``, ``push_back``, ``pop_back``, получение элемента по индексу через квадратные скобки. Кроме того, есть метод ``length``, который эквивалентен ``size``
(т.е. можно писать ``s.size()``, а можно ``s.length()``), доступно сложение строк (``s1 + s2`` — это строка ``s1``, к которой приписана строка ``s2``).

В отличие от числовых переменных, если не проинициализировать ``string``, она автоматически проинициализируется пустой строкой.

Отдельно скажу про ввод-вывод. Вывод осуществляется обычным ``cout << ...``. Ввод можно делать через ``cin >> ...``, но он тогда считывает строку *до первого пробела* 
(или перевода строки). Чтобы считать полную строку до перевода строки, надо писать ``getline(cin, s);``.

Конвертация числа в строку делается командой ``to_string``, например, ``string s = to_string(x);``. Конвертация обратно делается функциями ``stoi`` (string-to-int),
или ``stoll`` (string-to-long-long), в зависимости от требуемого типа на выходе.

Еще отдельно скажу про полезный тип данных ``istringstream`` (input string stream). Он позволяет превратить любую строку в «поток ввода», аналогичный ``cin``,
и дальше «считывать» из нее числа и прочие данные через ``>>``. Пишется так::

    #include <sstream>

    ...

    string s = "12 13";
    istringstream ss(s);
    int a, b;
    ss >> a >> b;  // получается a == 12, b == 13

Он особо полезен, когда вам надо считать числа «до конца строки». Вот так, например, можно одну строку входных данных превратить в массив чисел::

    string s;
    getline(cin, s);
    istringstream ss(s);
    vector<int> v;
    int x;
    while (ss >> x) {
        v.push_back(x);
    }

Здесь из незнакомых конструкций — только применение оператора ввода ``>>`` внутри ``while``. Дело в том, что любую операцию ввода можно использовать
в условии — это получается проверка того, был ли ввод успешным. Соответственно, цикл работает «пока получается считать число из ``ss``».
Цикл остановится, когда в ``ss`` не будет больше чисел.

Есть симметричный тип ``ostringstream`` (output string stream), в который можно выводить данные через ``<<``, а потом сконвертировать его в строку.
Но я подробно писать про него не буду, он намного реже нужен.

Наконец, отмечу, что как массивы, так и строки существуют в варианте C++ и существуют в варианте C. 
В стиле C для строки используется «сырой массив» символов (char'ов), который обычно обозначается ``char*`` или ``char[]``.
Не надо его использовать в ваших программах.

Вещественные числа
------------------

Напомню, что в целом современные процессоры поддерживают :ref:`три типа вещественных чисел<pythonBasicsFloatTypes>`:

-  **single** — хранит 7-8 цифр мантиссы, экспоненту до примерно ±40,
   занимает в памяти 4 байта, работает сравнительно быстро;
-  **double** — хранит 15-16 цифр мантиссы, экспонента до примерно ±300, занимает 8 байт,
   работает несколько медленнее;
-  **extended** — хранит 19-20 цифр мантиссы, экспонента
   до примерно ±5000, занимает в памяти 10 байт, работает намного медленнее;

В C++ доступны типы single (называется ``float``), double (так и называется ``double``), а также есть тип ``long double``,
который в зависимости от компилятора может быть или double, или extended.

В большинстве наших программ стоит использовать тип ``double`` или ``long double``; у типа ``float`` в наших задачах обычно не хватает точности.
Обратите, в частности, внимание, что в питоне ``float`` — это double, а в C++ ``float`` — это single.

Ввод-вывод также работает через ``cin``/``cout``, только надо иметь в виду, что ``cout`` по умолчанию округляет число
до шести значащих цифр. Нередко нам этого недостаточно, тогда надо просто в начале программы
например, например, ``cout.precision(20);`` — это потребует выводить 20 значащих цифр. Это, конечно, много и даже слишком много,
но хуже не будет, и лучше так, чем потерять точность при выводе.

Есть функции ``ceil``, ``floor``, ``trunc`` и ``round`` с тем же смыслом, что и в питоне; для их использования надо подключить заголовочный файл ``cmath`` (``#include <cmath>``).
Для взятия модуля (``abs``) тоже надо подключать ``cmath``, иначе могут быть разные неожиданности.

Все соображения про точность работы с вещественными числами и про eps, описанные в :ref:`соответствующем разделе текста про питон<pythonBasicsFloat>`, справедливы и для C++.

Логический тип данных
---------------------

Логический тип данных называется ``bool`` и может принимать два значения: ``true`` и ``false`` (с маленькой буквы). Как и в других языках, 
в переменную типа ``bool`` можно записывать напрямую результаты сравнений и других условий;
и переменную типа ``bool`` можно использовать напрямую в ``if``'ах, ``while``'ах и т.п.

.. note ::

    В отличие от других языков, ``bool`` — тоже *целочисленный тип*.
    Если вы пишете арифметическое выражение, то ``false`` превращается в ``0``, а ``true`` — в ``1``.
    Аналогично, логические операции на самом деле принимают не только ``true``/``false``,
    но и произвольные числа: ``0`` считается ``false``, а все остальные значения — ``true``::

        bool x = 1 + 2;  // 1 + 2 == 3, превратится в true.
        int y = x;  // x == true, превратится в 1.
        int z = x + 10;  // x == true, превратится в 1, 1 + 10 == 11.
        if (z) {  // работает так же, как if (z != 0).
        }
        cout << true << '\n';  // выведет 1.
        cout << false << '\n';  // выведет 0.
        cin >> x;  // ожидает на вход либо 0, либо 1, другие числа или строки нельзя.

    Но в целом не стоит так писать, в некоторых случаях это может приводить к незаметным ошибкам.
    Пишите проверки полностью (``z != 0``), как в ``if``'ах, так и при сохранениях ``int`` в ``bool``
    и в подобных случаях, ну и не используйте арифметические операции с ``bool``.

Функции
-------

Функция в общем виде определяется так::

    int foo(int x, double y, string s) {
        ...
    }

Это определена функция ``foo``, которая принимает три параметра: ``x`` типа ``int``, ``y`` типа ``double`` и ``s`` типа ``string``, и возвращает тип ``int``.
Если аргументов нет, то надо обязательно написать пустые скобки: ``int foo() {...}``.
Внутри функции для завершения функции и возврата значения используется команда ``return <значение>``.

Любая ветка исполнения функции обязана завершаться командой ``return <значение>``, ее отсутствие — это undefined behavior
(см. ниже), т.е. в случае ее отсутствия программа может вести себя вообще как угодно. (Исключение — функции, возвращающие ``void``, см. ниже.)

Особый случай — функции, не возвращающие ничего («процедуры», если пользоваться терминами паскаля). Для таких функций надо указать специальный
тип возвращаемого значения ``void``::

    void foo() {
       ...
    }

Соответственно, в таких функциях можно использовать только ``return`` без значения, и в месте вызова такой функции ее результат нельзя никак использовать.
Более того, можно не писать ``return`` в конце функции.

Локальные переменные внутри функции определяются стандартным образом: просто в коде функции объявляете переменную, когда она вам понадобилась.
Записи типа питоновской ``global`` в C++ нет; наоборот, поскольку все локальные переменные надо явно объявлять, то если вы используете
переменную, которую не объявляли, C++ будет думать, что это глобальная переменная (и если такой нет, то это будет ошибка компиляции).

Передача параметров в функции не так тривиальна, как в питоне. Во-первых, параметры можно объявлять как описано выше: просто тип и имя параметра.
Тогда при вызове такой функции значения будут копироваться в соответствующие локальные переменные, т.е. в примере выше ``x``, ``y`` и ``s``
будут копиями тех значений, которые были переданы в аргументы функции в момент вызова. Изменения в ``x``, ``y`` и ``s`` не будут видны наружу.
Это называется «передача параметров по значению».

Также возможна передача «по ссылке», она пишется так::

    int foo(int& x, double& y, string& s) {
        ...
    }

Теперь при вызове функции никаких копий переменных не делается, ``x``, ``y`` и ``s`` указывают на ту же переменную, ту же память, что была передана
в момент вызова функции. Т.е. если я вызываю функцию как ``foo(a, b, c)``, то внутри функции получается что ``x`` соответствует той же переменной, той же памяти,
что и ``a``, и изменения в ``x`` будут видны в ``a``, и аналогично с ``y`` и ``s``. Естественно, это тогда требует, чтобы при вызове функции 
в параметрах были указаны именно переменные, а не выражения, запись вида ``foo(q + w, b, c)`` не сработает, потому что ``q+w`` не есть переменная.

Передача по ссылке используется, когда вам надо реально снаружи функции видеть изменения переменных, но это считается довольно плохой практикой
(потому что в месте вызова функции совершенно неочевидно, что переменная будет меняться).

И есть передача «по константной ссылке»::

    int foo(const int& x, const double& y, const string& s) {
        ...
    }

Это примерно то же, что передача по ссылке, только теперь эти переменные невозможно изменить внутри функции. За счет этого, во-первых,
никакие изменения не будут видны снаружи (просто потому, что никаких изменений не будет вообще), во-вторых,
можно в ``foo`` передавать и выражения, а не только переменные (можно писать ``foo(q + w, b, c)``.

Передача по константной ссылке используется в первую очередь чтобы избежать копирования значений. Скопировать ``int`` — это недолго.
А вот скопировать ``string`` или ``vector`` может быть очень долго, если они длинные. А если вы передаете по константной ссылке,
то копирований не будет. Например, если вы хотите передавать граф (матрицу смежности или списки смежные вершин) в функцию
типа поиска в глубину, то передавайте по константной ссылке.

Естественно, варианты можно комбинировать как вам нужно, можно часть параметров передавать одним способом, часть — другим::

    int foo(int x, double& y, const string& s) {
        ...
    }


В целом, маленькие типы (в первую очередь примитивные типы данных, не массивы, не строки и не прочие сложные типы) обычно передают по значению,
а большие — по константной ссылке. Передача по значению используется
еще, если вам надо будет в функции все равно менять переменную, но так, чтобы снаружи
это не было заметно — тогда без копии, конечно, не обойтись.
Передаче по не-константной ссылке используется, если вам надо видеть изменения в переменной снаружи,
и используется довольно редко.


Файловый ввод-вывод
-------------------

Файловый ввод-вывод полностью аналогичен вводу с клавиатуры и выводу на экран. Надо подключить заголовочный файл ``fstream`` (от file stream),
после этого создать объект типа ``ifstream`` для ввода (input file stream) или ``ofstream`` для вывода (output file stream), указав в скобках имя файла,
и дальше работать с ними как с ``cin`` и ``cout``::

    #include <fstream>

    ....

    ifstream in("input.txt");
    int a, b;
    in >> a >> b;

    ofstream out("output.txt");
    out << a + b;

Вам может потребоваться читать данные «до конца файла». Для этого вы можете легко проверить, было ли чтение успешным: каждая операция чтения возвращает
некоторый объект (на самом деле тот же самый поток ввода), который можно проверить в условии ``if`` или ``while``. Например, 
так можно считать все числа из входного файла и посчитать их сумму::

    int sum = 0;
    int x;
    while (in >> x) {  // пока чтение успешно
        sum += x;
    }

При этом у объектов потоков (в данном случае ``in``) есть метод ``eof``, который сообщает, кончился ли уже файл, и вы можете захотеть написать типа

::

    // так делать не надо
    while (!in.eof()) {
        int x;
        in >> x;
        ...
    }


Но так не заработает. Дело в том, что файловый поток ввода узнает, что файл кончился, только после неуспешной попытки чтения.
Т.е. когда вы прочитали последнее число, условие ``in.eof()`` будет еще ложным. Вы попробуете считать еще одно число,
чтение будет неуспешным, в ``x`` что-то окажется (начиная с C++11 гарантируется, что там окажется ноль,
но я бы не полагался на это),
и только после этого ``in.eof()`` вернет ``true``. Естественно, это не то, что вы хотели.
Правильно проверять результат считывания числа через ``while (in >> x)`` или т.п.

Аналогично, не надо никогда читать ``while (in) {...}``, потому что проверка 
самого потока тоже станет ложной только *после* неудачного чтения.
